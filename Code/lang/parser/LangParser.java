package lang.parser;

import lang.ast.cmd.*;
import lang.ast.*;
import lang.ast.expr.*;
import lang.ast.types.*;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Lang.grammar".
 */
public class LangParser extends Parser {

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pDayTl4q4KnhzTsmbsWbDCueGO4mXE0eGQQgYcEYSuWP1ou0B$0HSEb0DmGE9Ak128G84" +
		"Wa40890v8b0DdckYzXzxxyCtmF1wjadjczTllc$SyixFF#m3SG0Oj68bH68q6Z444OJG5Oe" +
		"DefdwX2aaKeHPr667yHF5PzGSBrNiJQtNoiyGlnX8inJA#OKxznb2Ke0mL688GYk6hcpPVQ" +
		"PrU7NDsYeelLPym7PEvHzpieNEL9fTVcLMViTp4DNCn2MCn3#LcLGB3K8qQ34SpKXY71KYZ" +
		"7eqOZmcOWgbyuZJCm4pgRBHX3ZM6#LYaxgexwhQw1Gy#pnpcUnJnv2cU9nQ83QOPME4eOoK" +
		"ePRsqZubFCPTcTToOwyjOhmhMLRyX#0NKcsyWnY$2PxMQRDwpJg#EEplLYK#OcbVPFGedAZ" +
		"mZmRFekAQ1$uskUjAigkNi$vKXrRoqz#qzpkVajOR4ZVFi1RHlWHdho6goKUPho6QoWMoLM" +
		"3VPBdu7wIHxzLnYNIHALf9oYIL5q#GWoP0UqaBsaDRyUXUESuf3$67HDhADPCagYUqa5qcE" +
		"h2Ld97w9h23hoLboYfoNN2#v87wtw6NHA#GgkKQk1yxKePN7wWl4Tw5Gjmudlcc0T#iItIU" +
		"wNxHRz81eZ#YX$lQHN6TWtYjwf9$V7XKzviIEYvuGFUdaJelc1df#OFzso51$hVjfxjzbzb" +
		"5zi9atv3Nf8o$92$9AFLVFr5FrH3tax35vHEwPtpzGz#tQTt26UclkFyWtyiN6lof5QMHNU" +
		"jAPUkQnFptsROGKiHj2x2cDns$KPnTgFFQZJppsP8XT6I75xAEGW#zuBu2EXQtFK3FK5DMb" +
		"#HySkSeF");

	private final Action[] actions;

	public LangParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] lst$functionDec = functionDec
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [1] lst$functionDec = lst$functionDec functionDec
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [2] opt$lst$functionDec = 
			Action.RETURN,	// [3] opt$lst$functionDec = lst$functionDec
			new Action() {	// [4] program = opt$lst$functionDec.decs
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_decs = _symbols[offset + 1];
					final ArrayList _list_decs = (ArrayList) _symbol_decs.value;
					final Func[] decs = _list_decs == null ? new Func[0] : (Func[]) _list_decs.toArray(new Func[_list_decs.size()]);
					 return new Program(decs);
				}
			},
			new Action() {	// [5] functionDec = type.t ID.n LPAREN RPAREN block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final SType t = (SType) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Cmd b = (Cmd) _symbol_b.value;
					return new Func(t, n, null, b);
				}
			},
			new Action() {	// [6] functionDec = type.t ID.n LPAREN varDecList.p RPAREN block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final SType t = (SType) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_p = _symbols[offset + 4];
					final ArrayList _list_p = (ArrayList) _symbol_p.value;
					final Pair[] p = _list_p == null ? new Pair[0] : (Pair[]) _list_p.toArray(new Pair[_list_p.size()]);
					final Symbol _symbol_b = _symbols[offset + 6];
					final Cmd b = (Cmd) _symbol_b.value;
					return new Func(t, n, p, b);
				}
			},
			new Action() {	// [7] block = LBRACE commandList.c RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 2];
					final Cmd c = (Cmd) _symbol_c.value;
					 return c;
				}
			},
			new Action() {	// [8] varDecList = varDecList COMMA varDec
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [9] varDecList = varDec
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [10] varDec = type.t ID.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final SType t = (SType) _symbol_t.value;
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					  return new Pair(t,i);
				}
			},
			new Action() {	// [11] commandList = cmd.c commandList.l
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 1];
					final Cmd c = (Cmd) _symbol_c.value;
					final Symbol _symbol_l = _symbols[offset + 2];
					final Cmd l = (Cmd) _symbol_l.value;
					 return new Seq(c,l);
				}
			},
			new Action() {	// [12] commandList = cmd.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_c = _symbols[offset + 1];
					final Cmd c = (Cmd) _symbol_c.value;
					 return c;
				}
			},
			new Action() {	// [13] cmd = singlecmd.c SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol c = _symbols[offset + 1];
					 return c;
				}
			},
			new Action() {	// [14] cmd = stmt.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Cmd s = (Cmd) _symbol_s.value;
					 return s;
				}
			},
			new Action() {	// [15] singlecmd = ID.v ATTR expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final String v = (String) _symbol_v.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return new Attr(v,e);
				}
			},
			new Action() {	// [16] stmt = WHILE LPAREN expr.e RPAREN block.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final Cmd c = (Cmd) _symbol_c.value;
					 return new While(e,c);
				}
			},
			new Action() {	// [17] stmt = IF LPAREN expr.e RPAREN block.c ELSE block.d
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final Cmd c = (Cmd) _symbol_c.value;
					final Symbol _symbol_d = _symbols[offset + 7];
					final Cmd d = (Cmd) _symbol_d.value;
					 return new If(e,c,d);
				}
			},
			new Action() {	// [18] expr = expr.a PLUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Add(a ,b);
				}
			},
			new Action() {	// [19] expr = expr.a MINUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Sub(a ,b);
				}
			},
			new Action() {	// [20] expr = expr.a EQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Eq(a ,b);
				}
			},
			new Action() {	// [21] expr = NOT expr.e
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new Not(e);
				}
			},
			new Action() {	// [22] expr = expr.a LT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Lt(a ,b);
				}
			},
			new Action() {	// [23] expr = expr.a AND expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new And(a ,b);
				}
			},
			new Action() {	// [24] expr = NUMBER.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Integer n = (Integer) _symbol_n.value;
					 return new IntLit(n);
				}
			},
			new Action() {	// [25] expr = TRUE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new BoolLit(true);
				}
			},
			new Action() {	// [26] expr = FALSE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new BoolLit(false);
				}
			},
			new Action() {	// [27] expr = STRING.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final String s = (String) _symbol_s.value;
					 return new StrLit(s);
				}
			},
			new Action() {	// [28] expr = ID.v LPAREN RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final String v = (String) _symbol_v.value;
					 return new Call(v, null);
				}
			},
			new Action() {	// [29] expr = ID.v LPAREN argList.c RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final String v = (String) _symbol_v.value;
					final Symbol _symbol_c = _symbols[offset + 3];
					final ArrayList _list_c = (ArrayList) _symbol_c.value;
					final Expr[] c = _list_c == null ? new Expr[0] : (Expr[]) _list_c.toArray(new Expr[_list_c.size()]);
					 return new Call(v, c);
				}
			},
			new Action() {	// [30] expr = ID.v
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_v = _symbols[offset + 1];
					final String v = (String) _symbol_v.value;
					 return new Var(v);
				}
			},
			new Action() {	// [31] expr = LPAREN expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return e;
				}
			},
			new Action() {	// [32] argList = expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [33] argList = argList COMMA expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [34] type = BOOL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TyBool();
				}
			},
			new Action() {	// [35] type = INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TyInt();
				}
			},
			new Action() {	// [36] type = STR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TyString();
				}
			},
			new Action() {	// [37] type = VOID
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return new TyVoid();
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
